## AEL technical notes ##

### New AEL platform and ROM model

These changes improve the AEL experience and smooths the transition to the Kodi games database.

#### Artwork filename in PID, CID

Every piece of artwork has a default name with no number at the end. Additional artwork follow the Kodi extrafanart name convention, that is, adding a number at the end of the filename.

```
artname.png
artname1.png
artname2.png
artname_comment.png  --> Not implemented yet.
artname1_comment.png --> Not implemented yet.
```

#### Platform information directory (PID)

The PID can be used to automatically import ROM Launcher assets at launcher creation time.

The PID can be used to scan for images in the **Edit Launcher** menu, **Change launcher artwork**.

The layout of the PID is the following.

```
<pid>/<pname>/<pname>.nfo
<pid>/<pname>/banner.png
<pid>/<pname>/clearlogo.png
<pid>/<pname>/controller.png --> Picture of controller.
<pid>/<pname>/fanart.png
<pid>/<pname>/media.png      --> Picture of cartridge, CD, etc.
<pid>/<pname>/icon.png
<pid>/<pname>/poster.png
<pid>/<pname>/system.png     --> Picture of the system, SS picture or illustration.
```

`<pname>` is the standardized platform name. Extra artwork is supported for every asset, for example. `banner.png`, `banner1.png`, `banner2.png`.

When scanning for artwork the order of the platform name is: long name, short name, compact name.

When saving artwork the setting `pid_platform_name` with values {P_LONG_NAME, P_SHORT_NAME, P_COMPACT_NAME} sets the platform name to use.

#### ROM asset directory (RAD)

If the RAD is used, all ROMs belonging to the same platform share the same artwork.

Arcade/MAME and No-Intro games use different sets of artwork.

```
<rad>/<pname>/3dboxes/<ROM_name>.png     --> Could be autogenerated with an XML template.
<rad>/<pname>/banners/<ROM_name>.png
<rad>/<pname>/bezels/<ROM_name>.png      --> New. Should be included?
<rad>/<pname>/boxbacks/<ROM_name>.png
<rad>/<pname>/boxfronts/<ROM_name>.png
<rad>/<pname>/boxspines/<ROM_name>.png   --> New.
<rad>/<pname>/boxtextures/<ROM_name>.png --> New. Could be autogenerated with an XML template.
<rad>/<pname>/cartridges/<ROM_name>.png
<rad>/<pname>/clearlogos/<ROM_name>.png
<rad>/<pname>/fanarts/<ROM_name>.png     --> Could be autogenerated with an XML template.
<rad>/<pname>/flyers/<ROM_name>.png      --> Shold be renamed to posters?
<rad>/<pname>/manuals/<ROM_name>.png
<rad>/<pname>/maps/<ROM_name>.png
<rad>/<pname>/snaps/<ROM_name>.png
<rad>/<pname>/titles/<ROM_name>.png
<rad>/<pname>/trailers/<ROM_name>.png
```

Table sorting order: No-Intro exclusives, MAME/Arcade exclusives, all games common.

Rename `flyers` to `posters` to be consistent with Kodi artwork name. **NO**, I think it's better to keep the games name to differentiate from Movies posters.

`(auto)` means that can be autogenerated from other pieces of artwork with an XML template.

| Artname       | No-Intro available | MAME available | MAME SL available |
|---------------|--------------------|----------------|-------------------|
| `boxbacks`    | yes                |                | yes               |
| `boxfronts`   | yes                |                | yes               |
| `boxspines`   | yes (new)          |                | yes               |
| `boxtextures` | yes (new, auto)    |                | yes               |
| `cartridges`  | yes                |                | yes               |
| `cabinets`    |                    | yes            |
| `cpanels`     |                    | yes            |
| `PCBs`        |                    | yes            |
| `3dboxes`     | yes (auto)         | yes (auto)     | yes (auto)        |
| `banners`     | yes                | yes            |
| `bezels`      | yes (new)          | yes (new)      | yes (new)         |
| `clearlogos`  | yes                | yes            |
| `fanarts`     | yes (auto)         | yes (auto)     | yes (auto)        |
| `flyers`      | yes                | yes            |
| `manuals`     | yes                | yes            |
| `maps`        | yes                | yes            |
| `snaps`       | yes                | yes            | yes               |
| `titles`      | yes                | yes            | yes               |
| `trailers`    | yes                | yes            |

#### Category information directory (CID)

Same as the PID but used for Category metadata/artwork.

Scraping of Category artwork is no supported. User must place their assets on disk.

```
<cid>/<cname>/<cname>.nfo
<cid>/<cname>/banner.png
<cid>/<cname>/clearlogo.png
<cid>/<cname>/fanart.png
<cid>/<cname>/icon.png
<cid>/<cname>/poster.png
```

#### AEL theme directory (ATD)

The default ATD is distributed with AEL in `ADDON_CODE_PATH/media/theme`.

If tue user wants to change the AEL theme then it must change the ATD in AEL settings and then execute an utility to refresh the theme images.

```
<atd>/Browse_AEL_Offline_<arttype>.png
<atd>/Browse_by_Category_<arttype>.png
...
<atd>/Utilities_<arttype>.png
```

#### Canonical example of Launcher XML file

Current versions of AEL use the `<ROM_asset_path>` and the `<path_xxxxx>` tags.

Future AEL versions use the RAD or only use `<ROM_asset_path>` and the `<subpath_xxxxx>` tags in case the user wants to change the default artwork subdirectory names.

If user wants to use the RAD then `<ROM_asset_path>RAD</ROM_asset_path>`. This is the default if the tag is missing.

If user wants the artwork next to ROMs then `<ROM_asset_path>NextToROMs</ROM_asset_path>`

```
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<advanced_emulator_launcher_configuration>
<!-- New category. This allows to set the metadata/artwork directories -->
<main>
  <!-- This allows to set the metadata/artwork directories and the change is permanent. -->
  <CID_path></CID_path>
  <PID_path></PID_path>
  <PID_path></PID_path>
  <ATD_path></ATD_path>
</main>

<launcher>
  <name>PlayStation (Retroarch)</name>
  <platform>Sony PlayStation</platform>
  <category>SONY</category>
  <application>/home/kodi/bin/retroarch</application>
  <args>-L /home/kodi/bin/libretro/mednafen_psx_libretro.so -f -v &quot;$rom$&quot;</args>
  <Options>Blocking</Options>
  <ROM_path>/home/kodi/AEL-ROMs/sony-psx/</ROM_path>
  <ROM_ext>chd</ROM_ext>
  <ROM_asset_path>/home/kodi/AEL-assets/sony-psx/</ROM_asset_path>
  <path_title> --> Deprecated
  <path_snap>  --> Deprecated
  ...
  <subpath_title>
  <subpath_snap>
  ...

  <Launcher_NFO>Playstation.nfo</Launcher_NFO>
  <year>1994</year>
  <genre>Fifth generation console</genre>
  <developer>SONY</developer>
  <rating></rating>
  <plot>The PlayStation is a home video game console released on 3 December 1994.</plot>

  <Asset_Prefix>PlayStation</Asset_Prefix>
  <s_icon />
  <s_fanart />
  <s_banner />
  <s_poster />
  <s_clearlogo />
  <s_controller />
  <s_trailer />
</launcher>
</advanced_emulator_launcher_configuration>
```

#### Examples of Launcher creation

**Launcher metadata and artwork taken from PID. ROMs artwork in RAD**

Category metadata/artwork taken from CID if the category is new.

```
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<advanced_emulator_launcher_configuration>
<launcher>
  <name>PlayStation (Retroarch)</name>
  <category>SONY</category>
  <platform>Sony PlayStation</platform>
  <application>/home/kodi/bin/retroarch</application>
  <args>-L /home/kodi/bin/libretro/mednafen_psx_libretro.so -f -v &quot;$rom$&quot;</args>
  <ROM_path>/home/kodi/AEL-ROMs/sony-psx/</ROM_path>
  <ROM_ext>chd</ROM_ext>
  <!-- Can be omitted because this is the default -->
  <ROM_asset_path>RAD</ROM_asset_path>
</launcher>
</advanced_emulator_launcher_configuration>
```

**Launcher metadata and artwork taken from PID. ROMs artwork in custom dir**

```
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<advanced_emulator_launcher_configuration>
<launcher>
  <name>PlayStation (Retroarch)</name>
  <category>SONY</category>
  <platform>Sony PlayStation</platform>
  <application>/home/kodi/bin/retroarch</application>
  <args>-L /home/kodi/bin/libretro/mednafen_psx_libretro.so -f -v &quot;$rom$&quot;</args>
  <ROM_path>/home/kodi/AEL-ROMs/sony-psx/</ROM_path>
  <ROM_ext>chd</ROM_ext>
  <ROM_asset_path>/home/kodi/AEL-assets/sony-psx/</ROM_asset_path>
  <!-- Only if user want to change the default artwork subdirectory names -->
  <subpath_title />
</launcher>
</advanced_emulator_launcher_configuration>
```

**Launcher metadata and artwork taken from PID. ROMs artwork next to ROMs**

```
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<advanced_emulator_launcher_configuration>
<launcher>
  <name>PlayStation (Retroarch)</name>
  <category>SONY</category>
  <platform>Sony PlayStation</platform>
  <application>/home/kodi/bin/retroarch</application>
  <args>-L /home/kodi/bin/libretro/mednafen_psx_libretro.so -f -v &quot;$rom$&quot;</args>
  <ROM_path>/home/kodi/AEL-ROMs/sony-psx/</ROM_path>
  <ROM_ext>chd</ROM_ext>
  <ROM_asset_path>NextToROMs</ROM_asset_path>
</launcher>
</advanced_emulator_launcher_configuration>
```

### Implementation algorithms

Keep in mind standalone launchers and special launchers in future AEL releases.

#### Importing a Launcher XML file

**Algorithm for metadata**

 1. Read the full metadata tags (`<year>`, ...)

 2. Read the Launcher NFO file if set with `<Launcher_NFO>`.

 3. **ONLY FOR ROM Launchers** Search for the Launcher NFO file in the PID.

 4. The priority to set the metadata is; 1) full metadata tags, 2) Launcher NFO file and 3) PID.

 5. Database `m_xxxxx` fields are set.

**Algorithm for artwork**

 1. Read the absolute-path artwork tags (`<s_xxxxx>`, ...).

 2. Read the `<Asset_Prefix>` tag and scan for artwork.

 3. **ONLY FOR ROM Launchers** Search for launcher artwork in the PID depending on the platform name.

 4. The priority to set the artwork is; 1) absolute-path tags, 2) `<Asset_Prefix>` and 3) PID.

 5. If more than one piece of artwork is found then a image selection dialog is shown to the user.

 6. Database `s_xxxxx` fields are set.

#### Full configuration XML saving/backup

When saving an XML backup of all Categories and Launchers the full metadata tags (`<year>`, ...) and the absolute-path artwork tags (`<s_xxxxx>`, ...) are always used. The following tags are never used; `<Launcher_NFO>`, `<Asset_Prefix>`. The following tags are only saved if set; `<subpath_title>`

#### Saving a Launcher XML file

Same as the full configuration backup.

#### ROM scanner scanning for artwork

**Algorithm for metadata**

 1. Write me. In principle the current AEL implementation should be OK.

**Algorithm for artwork**

 1. If `<ROM_asset_path>` has a value of `RAD` then use the RAD. Create the platform directory and the artwork subdirectories in the RAD.

 2. If `<ROM_asset_path>` is a custom directory then use it. Create the artwork subdirectories.

 3. If `<ROM_asset_path>` has a value of `NextToROMs` then scan/store artwork next to the ROMs using the `NextToROMs` naming scheme.

#### Importing/Saving a Category XML file

Same as a Launcher import/saving.

### Current menus in 0.9.8

Context menu **Edit Launcher**, submenu **Manage ROMs ...**:
```
'Choose ROMs default artwork ...',
'Manage ROMs asset directories ...',
'Rescan ROMs local artwork',
'Scrape ROMs artwork',
'Remove dead/missing ROMs',
'Import ROMs metadata from NFO files',
'Export ROMs metadata to NFO files',
'Delete ROMs NFO files',
'Clear ROMs from launcher',
```

Context menu **Edit Launcher**, submenu **Audit ROMs / Launcher view mode ...**:
```
'Change launcher display mode (now {0}) ...'.format(display_mode_str),
'Add No-Intro/Redump XML DAT ...' OR 'Delete No-Intro/Redump DAT: {0}'
'Create Parent/Clone DAT based on ROM filenames',
'Display ROMs (now {0}) ...'.format(launcher['nointro_display_mode']),
'Update ROM audit',
```

**Display modes** are `LAUNCHER_DMODE_FLAT`, `LAUNCHER_DMODE_PCLONE` and `LAUNCHER_DMODE_1G1R`.
PCLONE and 1G1R are the same, the difference is that in 1G1R the ROM Context 
Menu **Show clones** is displayed and Parents are launcher automatically. AML now has
FLAT and 1G1R modes only.

**Display filters** are `NOINTRO_DMODE_ALL`, `NOINTRO_DMODE_HAVE`, `NOINTRO_DMODE_HAVE_UNK`,
`NOINTRO_DMODE_HAVE_MISS`, `NOINTRO_DMODE_MISS`, `NOINTRO_DMODE_MISS_UNK`, `NOINTRO_DMODE_UNK`.

Current fields in Launchers database:

```
'nointro_xml_file' : '',
'nointro_display_mode' : NOINTRO_DMODE_ALL,
'launcher_display_mode' : LAUNCHER_DMODE_FLAT,
```

Current fields in ROMs database:

```
'disks' : [],
'nointro_status' : 'Miss',
'pclone_status' : 'Parent',
'cloneof' : '',
```

### Menus in future AEL releases

Context menu **Edit Launcher**, submenu **Manage ROMs ...**:

```
'Choose ROMs default artwork...',
'Manage ROMs asset directories...',
'Rescan ROMs local artwork',
'Scrape ROMs artwork',
'Import ROMs metadata from NFO files',
'Export ROMs metadata to NFO files',
'Delete ROMs NFO files',
'Delete ROMs from launcher',
```

Context menu **Edit Launcher**, submenu **Audit ROMs / Launcher view mode ...**:

```
'Launcher display mode (now {})...'.format(display_mode_str),
'Audit display filter (now {})...'.format(launcher['display_filter']),
'Audit launcher ROMs',
'Undo ROM audit (remove missing ROMs)',
'Add custom XML DAT ...' OR 'Delete custom XML DAT',
```

**Launcher display modes** are `LAUNCHER_DMODE_FLAT` (default) and `LAUNCHER_DMODE_PCLONE`.

**Launcher audit status** are `AUDIT_STATE_ON`, `AUDIT_STATE_OFF` (default).

**Launcher audit display filter** `AUDIT_FILTER_ALL` (default), `AUDIT_FILTER_HAVE`, `AUDIT_FILTER_HAVE_UNK`, `AUDIT_FILTER_HAVE_MISS`, `AUDIT_FILTER_MISS`, `AUDIT_FILTER_MISS_UNK`, `AUDIT_FILTER_UNK`. For now, always display Extra ROMs.

### Future AEL guidelines

The Parent/Clone information is ALWAYS computed, regardles of the audit status, whenever the launcher ROMs change.

The ROM region information is ALWAYS computed, regardless of the audit status, whenever the launcher ROMs change.

The Parent of the Parent/Clone group is chosen according to the preferred Region and Language. User selects the preferred Region and Language with global settings. These global settings may be overriden with Launcher-specific settings.

The Launcher display mode is always available.

The Launcher audit display filter is available if and only if the audit status is ON.

The ROM Audit is very easy to do. The difficult part is to make the Parent/Clone groups and choosing the parent ROM.

Future fields in Launchers database:

```
'audit_state' : AUDIT_STATE_ON or AUDIT_STATE_OFF,  Reports if audit is ON or not
'audit_auto_dat_file' : '',                         Filled in automatically
'audit_custom_dat_file' : '',                       Previous nointro_xml_file
'audit_display_mode' : AUDIT_DMODE_ALL,             Previous nointro_display_mode
'launcher_display_mode' : LAUNCHER_DMODE_FLAT,
```

Future ROMs database fields:

```
'm_cloneof' : '',              Override the ROM parent. ROM_base_noext (read-only field)
'm_regions' : ['', ''],        Override the ROM regions (read-only field)
'm_languages' : ['', ''],      Override the ROM languages (read-only field)
'disks' : [],
'i_audit_status' : 'Have',     Determined by the ROM Audit exclusively, former nointro_status
'i_pclone_status' : 'Parent',  Based on i_cloneof, used to set skin properties, former pclone_status
'i_cloneof' : ROMID_MD5_str,   ROM ID of the final parent ROM, former cloneof
'i_extra_ROM' : bool,          If True ROM is an extra ROM, false otherwise
'i_order' : int,               Position of the ROM in the Parent/Clone group
'i_regions' : ['', ''],        Same as m_region
'i_languages' : ['', ''],      Same as m_language
'i_tags' : ['', ''],           Always extracted from filename
                               Other unrecognised tags not region or language
```

Metadata `m_xxxxx` fields indicate user-configurable fiels. `i_xxxxx` indicate AEL internal and automatic fields, users are not able to edit directly.

`i_audit_status` can have values...

`i_pclone_status` can have values...

### Computation of the Parent/Clone ROM groups and group order

 1. First Parent/Clone groups are computed:
 
    1. If a No-Intro XML DAT is available it will be used.
       For Have and Missing ROMs take `i_cloneof` from the DAT.
       For Have and Missing ROMs extract `i_regions` and `i_languages` from filename.

    2. The Offline Scraper database will be used next, or first if the DAT is not found.
       For found ROMs `i_cloneof`, `i_regions` and `i_languages` will be taken from the database.

    3. For Unknown ROMs, the ROM basename will be used to compute `i_cloneof` and `i_regions`
       and `i_languages` extracted from the filename.

    4. The fiels `m_cloneof`, `m_region` and `m_language` in the ROM metadata override any of 
       the `i_*` fields.

 2. With the fields `i_cloneof`, `i_regions`, `i_languages` and `i_tags` the order in the
    Parent/Clone group is calculated:

    1. User chooses the primary and secondary ROM regions in AEL settings from a fixed list.

    2. User chooses the primary and secondary ROM languages in AEL settings from a fixed list.

    3. Other tags like (Rev X) are used to choose the preferred Parent in the set.
       AEL needs to have an histogram of all the No-Intro and Redump tags and
       use the information when building the Parent/Clone groups according to the settings.

    4. PClone groups are reordered according to the user settings. The Parent of the group will
       be the first ROM in the set.

    5. `i_cloneof` is updated to reflect the new Parent of each set.

    6. `i_order` is updated to reflect the ROM positions in the set.

    6. The file `roms_<Launcher_name>_PClone_index.json` is created.
       This file is used when rendering the PClone group list when the user select the
       context menu "Show clone ROMs".

    7. To render the Parent ROMs in PCLONE launcher display mode open the ROM JSON database
       and render only the Parent ROMs.

A report of the PClone group generation should be generated so the user can check for errors
or unwanted configurations.

**Potential problems**

 * What if the parent of a PClone group is a Missing ROM?

   1. If all ROMs in the PClone group are Missing choose the Parent ROM as usual.

   2. Otherwise, short the ROMs in the group according to the user preferences and choose
      the first Have or Unknown ROM as Parent.

 * What if the user wants to force a specific Parent? How to do this?

   1. The Parent can be changed with the ROM Region and ROM Language settings.

   2. Maybe having a read-only setting bool `m_forceparent`???
      This can create a conflict in the settings that must be solved.

 * What if there is a conflic when creating the Parent/Clone groups? For example, the No-Intro
   DAT says the Parent of a ROM is A and the user sets the parent of the ROM to B.

   1. A report of the Parent/Clone groups must be created so the user knows what happened
      and fix any error or misconfiguration. This report can be read using the Launcher
      context menu.

### Computation of the ROM Audit

 1. Only ROMs in the main ROM directory are audited.

 2. All ROMs in the extra ROM directory are Extra ROMs. Extra ROMs can be ROM hacks, etc., which
    are not in the official DATs but may be included in the Offline Scraper database.

 3. The XML DAT for No-Intro ROMs is chosen automatically from the No-Intro DAT directory 
    as a function of the platform launcher.

 4. The XML DAT for Redump ROMs is chosen automatically from the Redump DAT directory 
    as a function of the platform launcher.

 5. Users can manually configure a custom XML DAT file for every launcher.
    In this case, the automatic DAT selection is ignored.

 6. The Offline Scraper database can be used for the ROM Audit instead of an external DAT XML file.

**Potential problems**

 1. How to audit multidisc ROMs???

    1. For now, do not allow multidisc ROMs and ROM Audit for the same launcher at the same time.

### Examples of ROM Audit and Parent/Clone generation

Complete example of SNES ROMs including all cases except multidisc ROMs.

```
Kaizo Mario World (Japan)                       -- EXTRA ROM / Different basename from any ROM in set
Kaizo Mario World 2 (Japan)                     -- EXTRA ROM / Different basename from any ROM in set
Super Mario World - Super Mario Bros. 4 (Japan) -- CLONE ROM / Different basename from any ROM in set
Super Mario World (Europe)                      -- CLONE ROM
Super Mario World (Europe) (Rev 1)              -- PARENT ROM / According to No-Intro DAT
Super Mario World (Japan) (En) (Arcade) [b]     -- MISSING ROM / CLONE ROM
Super Mario World (USA)                         -- CLONE ROM
```

To be written...

### Multidisc support

In the current implementation there is a virtual ROM in the database that represents all the ROMs in the set. The virtual multidisc ROM have the ROM basenames of the set in the `disks` list. This implementation has problems with the ROM audit because not all the real ROMs are in the database.

#### Multidisc ROM scanner implementation (current)

 1. Determine if the ROM is a multidisc ROM using the ROM filename. If so, determine the **set name** (ROM basename excluding the multidisc tag), the **disk name** (ROM basename), the **set index**, and so on. For example, set name = `Final Fantasy VII (USA)`, disk name = `Final Fantasy VII (USA) (Disc 3)` and set index = `3`.

 2. Check if the set exists in the database. Linear search of the set name in the base name of the `filename` field of all ROMs.

 3. If the set is not found:

    a. Set the `filename` field to ROM_dir + set name, for example `/home/kodi/ROMs/Final Fantasy VII (USA)`. It is important to have this name because the `filename` field could be used to determine the ROM artwork if option `<ROM_asset_path>NextToROMs</ROM_asset_path>` is set.

    b. The ROM basename is added to the `disks` list.

    c. Asset names will have the basename of the set `Final Fantasy VII (USA)`.

 4. If the set is found (set ROM already exists):

    a. The disk name is added to the `disks` list.

    b. `disks` list is reordered so ROMs have consecutive order.

```
m_title : whatever_str,
filename = '/home/kodi/ROMs/Final Fantasy VII (USA)'
disks = ['Final Fantasy VII (USA) (Disc 1).cue', 'Final Fantasy VII (USA) (Disc 3).cue']
```

ROMs not in a set have an empty `disks` list.

This implementation is safe if there are No-Intro missing ROMs in the set.

At launching time, users selects from a select dialog of the basenames of the roms of the set which one to launch.

#### Multidisc ROM scanner implementation (new)

In the new implementation for each multidisc group there is a **multidisc virtual set ROM** that represents the whole set and also there is a **multidisc ROM** database entry for each ROM in the set. This resolves the problem with the ROM audit.

The `filename` field of the **multidisc virtual set ROM** is set to `ROM.getDir()` + `set_name`, for example `/home/ROMs/psx/Final Fantasy VII (USA)`. It is important to have this name because the `filename` field could be used to determine the ROM artwork if option `<ROM_asset_path>NextToROMs</ROM_asset_path>` is set.

The `disk_status` field can be determined on the fly from `disks` and `disk_parent`, for example to differentiate a normal ROM from a multidisc ROM. However, the field `disk_status` is included to speed up ROM rendering and processing.

Launcher multidisc fields:

```
'multidisc' : bool,
```

Example of a normal ROM:

```
disk_status : MULTIDISC_NONE,
disks : [],
disk_parent : '',
```

Example of a multidisc virtual set ROM (multidisc ROM that represents the set):

```
m_title : 'Final Fantasy VII (USA)',
filename : '/home/ROMs/psx/Final Fantasy VII (USA)',
disk_status : MULTIDISC_VIRTUAL,
disks : [ROMID_1_MD5_str, ROMID_2_MD5_str, ...],
disk_parent : '',
```

Example of a multidisc ROM (multidisc ROM that belongs to a set):

```
m_title : 'Final Fantasy VII (USA) (Disc 1)',
filename : '/home/ROMs/psx/Final Fantasy VII (USA) (Disc 1).cue',
disk_status : MULTIDISC_ROM,
disks : [],
disk_parent : ROMID_MD5_str,
```

**ROM scanner algorithm for multidisc sets**

If `multidisc` is `True` and the user sets it to `False` then the **multidisc virtual set ROMs** are removed and the **multidisc ROMs** converted to normal ROMs. If `multidisc` is `False` and then the user sets it to `True` the ROM scanner must be run to create the **multidisc virtual set ROMs** and to convert the multidisc normal ROMs into **multidisc ROMs**.

Maybe doing the ROM scanning for the multidisc case in one pass is difficult. It could be simpler to do a first pass to scan and process metadata/assets of all ROMs, and then do a second pass to remove dead **multidisc virtual set ROM** and to create new **multidisc virtual set ROM**.

Another feature to code is a consistency checker that verifies the consistency of the whole ROMs database in AEL. This could be necessary every time the ROMs in the launcher are changed (added or removed).

**IMPORTANT** This algorithm is incomplete, finish it!

 1. First pass is to remove dead real ROMs (`filename` not found), No-Intro/Redump missing ROMs. Do not remove **multidisc virtual set ROMs**.

 2. In the second pass process each real ROM as normal. Scrape assets and metadata for all ROMs.

 3. In the third pass add No-Intro/Redump missing ROMs if audit is enabled. Missing ROMs are never scraped for metadata/assets.

 4. In the fourth pass remove dead **multidisc virtual set ROMs**. Traverse all the ROMs in the database. For each ROM determine if the ROM is a **multidisc ROM** using the ROM filename and also determine if the ROM is a **multidisc virtual set ROMs**.

    If the ROM is a **multidisc ROM** then determine the **set name** (ROM basename excluding the multidisc tag), the **disk name** (ROM basename), the **set index**, and so on. For example, set name = `Final Fantasy VII (USA)`, disk name = `Final Fantasy VII (USA) (Disc 3)` and set index = `3`. 

 5. In a fourth pass

 4. If the ROM is a **multidisc virtual set ROM** it means it was in the DB before the ROM scanner. In this case verify that all set multidisc ROMs exist. If a **multidisc ROMs** cannot be found by ROM ID then remove it from the `disks` list. If at the end the `disks` field is empty then remove this **multidisc virtual set ROM**.

 5. Else If the ROM is a **multidisc ROM** and the **multidisc virtual set ROM** is not found:

    a. Create the **multidisc virtual set ROM**.

    c. Process metadata and assets for the **multidisc virtual set ROM** only and not for the multidisc ROM.

 6. Else If the ROM is a **multidisc ROM** and the **multidisc virtual set ROM** is found:

    a. Modify the `disks` field of the **multidisc virtual set ROM**.

 7. ROMs database consistency check.

### No-Intro ROM names

The official No-Intro naming convention PDF can be downloaded from [DAT-o-matic](https://datomatic.no-intro.org/) website.

The only mandatory elements are the **Title** and the **Region**.

### Redump/Trurip/TOSEC ISO names

[No-Intro](http://www.no-intro.org/index.html)

[TOSEC naming convention](http://www.tosecdev.org/tosec-naming-convention)

| Organisation | Name example                                                  |
|--------------|---------------------------------------------------------------|
| **TOSEC**    | `Final Fantasy VII (1999)(Square)(NTSC)(US)(Disc 1 of 2).cue` |
|              | `Final Fantasy VII (1999)(Square)(NTSC)(US)(Disc 2 of 2).cue` |
| **Trurip**   | `Final Fantasy VII (EU) - (Disc 1 of 3).cue`                  |
|              | `Final Fantasy VII (EU) - (Disc 2 of 3).cue`                  |
|              | `Final Fantasy VII (EU) - (Disc 3 of 3).cue`                  |
| **Redump**   | `Final Fantasy VII (USA) (Disc 1).cue`                        |
|              | `Final Fantasy VII (USA) (Disc 2).cue`                        |
|              | `Final Fantasy VII (USA) (Disc 3).cue`                        |

### TOSEC/Trurip/Redump image formats

| TOSEC       | Redump  | Trurip          |
|-------------|---------|-----------------|
| cue,iso,wav | cue,bin | cue,img,ccd,sub |

### ROM Collections

Way of storing ROM Collections when saving the collection:

```
Sonic the Hedgehog.json
Sonic the Hedgehog_banner.png
Sonic the Hedgehog_fanart.png
Sonic the Hedgehog_icon.png
Sonic the Hedgehog_poster.png
Sonic the Hedgehog/Sonic The Hedgehog (USA, Europe)_fanart.png         --> megadrive
Sonic the Hedgehog/Sonic The Hedgehog (USA, Europe)_title.png
Sonic the Hedgehog/Sonic The Hedgehog (USA, Europe)_snap.png
Sonic the Hedgehog/Sonic The Hedgehog (USA, Europe, Brazil)_fanart.png --> sms
Sonic the Hedgehog/Sonic The Hedgehog (USA, Europe, Brazil)_title.png
Sonic the Hedgehog/Sonic The Hedgehog (USA, Europe, Brazil)_snap.png
```

There could be more than one image that will be shown to the user when importing the ROM Collection JSON file. The user then chooses what image to import. This applies to the artwork of the collection itself and to the Collection ROMs:

```
Sonic the Hedgehog.json
Sonic the Hedgehog_fanart.png
Sonic the Hedgehog_fanart1.png
Sonic the Hedgehog_fanart2.png
Sonic the Hedgehog_fanart3.png
```

If two ROMs in different platforms have the same filename then a platform compact name suffix is added to resolve the filename collision. Platform Long, Short and Compact names can be used:

```
Sonic the Hedgehog/Sonic The Hedgehog (USA, Europe)_megadrive_fanart.png
Sonic the Hedgehog/Sonic The Hedgehog (USA, Europe)_megadrive_title.png
Sonic the Hedgehog/Sonic The Hedgehog (USA, Europe)_megadrive_snap.png
Sonic the Hedgehog/Sonic The Hedgehog (USA, Europe)_sms_fanart.png
Sonic the Hedgehog/Sonic The Hedgehog (USA, Europe)_sms_title.png
Sonic the Hedgehog/Sonic The Hedgehog (USA, Europe)_sms_snap.png
```

### listitem.setInfo() overlay values and effects

`listitem.setInfo('video', {'overlay'  : 4})`

Kodi Krypton Estuary displays a small icon to the left of the listitem title that can be changed with the overlay property value. Overlay values are defined in [GUIListItem]:

```
enum GUIIconOverlay {
    ICON_OVERLAY_NONE = 0,
    ICON_OVERLAY_RAR,
    ICON_OVERLAY_ZIP,
    ICON_OVERLAY_LOCKED,
    ICON_OVERLAY_UNWATCHED,
    ICON_OVERLAY_WATCHED,
    ICON_OVERLAY_HD
};
```

[setInfo]: http://mirrors.xbmc.org/docs/python-docs/16.x-jarvis/xbmcgui.html#ListItem-setInfo
[GUIListItem]: https://github.com/cisco-open-source/kodi/blob/master/xbmc/guilib/GUIListItem.h

### Misc stuff

Nothing at the moment.
